# 2025-12-09 - 일일 기록

##  주요 업무 및 작업

* **Matplotlib 시각화 기능 개선 작업 완료.**
    * 랜드마크 이름 패턴(`X.1`, `X.2`)에 맞춰 쌍 랜드마크 추출 로직을 수정함.
    * GT/PRED 쌍 랜드마크를 각각 파란색/빨간색 실선으로 연결하는 기능을 추가함.
    * 랜드마크 오차 벡터를 노란색의 미세 점선(`dashes=(0.3, 0.3)`)으로 표시하도록 스타일 변경함.
* **3D 랜드마크 모델 성능 재검토 완료.**
    * 이전에 학습한 60 epoch 모델을 다른 테스트 케이스들로 재검증했음.
    * 이전에 발표했던 Case 02가 **가장 성능이 낮은 워스트 케이스**였음을 확인했음.
    * 다른 케이스들은 Case 02만큼 나쁘지는 않았으나, 전반적인 성능 최적화를 위해 **재학습 필요성**을 결론 내림.

---

##  배운 점 및 인사이트

* **Matplotlib `dashes` 사용법:** `plt.plot()`에서 `dashes=(선 길이, 간격 길이)` 튜플을 사용하여 점선 패턴을 원하는 대로 미세하게 제어할 수 있음을 알게 됨.
* **성능 평가의 함정:** 일부러 워스트 케이스를 기준으로만 성능을 판단하는 것은 모델의 잠재력을 저평가할 수 있으므로, 재검증 시 다양한 케이스를 활용해야 함.
* **재학습 계획:** 현재 모델이 완전 최악은 아니므로, 학습 과정을 곱씹어보며 성능을 끌어올릴 것임.
* **인코딩 문제 해결:** Windows 터미널에서 유니코드 출력 시 발생하는 `UnicodeEncodeError`를 `sys.stdout` 인코딩을 UTF-8로 설정하여 해결함.

---

##  문제 해결 및 코드 예시

### 코드 예시 1: 랜드마크 쌍 인덱스 추출 로직
```python

landmark_names = []

LM_PAIRS = []
lm_map = {name: idx for idx, name in enumerate(landmark_names)}

# 이름이 '.1' 또는 '.2'로 끝나는 랜드마크의 베이스 이름만 추출
bases = sorted(list(set([name.split('.')[0] for name in landmark_names if name.endswith(('.1', '.2'))])))

for base in bases:
    name_1 = f"{base}.1"
    name_2 = f"{base}.2"
    
    if name_1 in lm_map and name_2 in lm_map:
        LM_PAIRS.append([lm_map[name_1], lm_map[name_2]])

```
### 코드 예시 2: 미세 점선 오차 벡터 시각화
```python
# 설정: 미세 점선 패턴 정의
FINE_DASH_PATTERN = (0.3, 0.3)

# 함수 내 오차 벡터 시각화 적용
ax.plot([gt_x, pred_x], [gt_y, pred_y], 
        color=ERROR_LINE_COLOR, 
        dashes=FINE_DASH_PATTERN, 
        linewidth=2.5, zorder=4, alpha=1.0)
```
##  내일 할일
- 기업방문전 최종점검
- 3D모델 테스트